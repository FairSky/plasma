* extend Peer to support the graph API directly without with-peer-graph
* start using transactions

* add a function to peer that returns its url

* Add a (graph-event-channel [g]) which will publish an event any time the graph
is modified.

* Add a sum operator and query form

* figure out an error handling policy and right some helpers to
 - make it quick and easy to throw exceptions from query-plan builder
functions when bad arguments are passed
 - report on errors that occurred during query processing

 ** maybe pipelines?

* Query form (ala construct and query) to:
- update node/edge
- delete node/edge

* extend expressions to work on edge property predicates
 - path macro needs to do similar rebinding as the where macro

-----------

* recursive queries
* create a recur-query that will smartly be both local and remote
depending on whether it gets a proxy node as a result

----------

* new peer connections should always send their URL as the first message so they
  can be correctly stored in the connection cache, otherwise we just have the
  outgoing port number...

* when a connection is closed (or fails) remotely we need to close it and remove
 it from the connection cache.

* Add various error handling tests for connections and peer operations, and
look at moving some of the code to pipelines.

------------

Supporting experiments:

* enable logging of typical networking metrics:
 - bytes
 - messages
 - peers
 - latency

* implement recursive and iterative operators

* implement query packet TTL counter that decrements at each hop
 - packets dropped when (zero? TTL)

----------------------------------------------------------

Move to records and a standard protocol for query.operators:

* Goal: standardize the interface and access to important operator info
  - dataflow dependencies for optimizing query plan
  - specific arguments by name for re-organizing operators, combining operators

methods:
* branch?
 - replaces the operator/op-branch-map
* plan version
* instance version

-------------------------------
Longer Term:
-------------------------------

* look into jiraph versioning mechanism

-----------

* represent queries using a query specification, rather than the query plan
operator tree

* query spec map:
 - paths
 - selections
 - expressions
 - property-loads (to load as we traverse)
 - projection
