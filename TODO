* Add a (graph-event-channel [g]) which will publish an event any time the graph
is modified.

* Add an "as" feature to project so it can rename properties in case of
conflicts

* Also let path take an optional plan as its first argument, which would
let further paths bind on previously bound elements.

-----------

* represent queries using a query specification, rather than the query plan
operator tree

* query spec map:
 - paths
 - selections
 - expressions
 - property-loads (to load as we traverse)
 - projection
-----------

* recursive queries
* create a recur-query that will smartly be both local and remote
depending on whether it gets a proxy node as a result

----------

* distinct operator

* some kind of link-union function that can take a set of peer nodes and link up the new ones

* new peer connections should always send their URL as the first message so they
  can be correctly stored in the connection cache, otherwise we just have the
  outgoing port number...

* when a connection is closed (or fails) remotely we need to close it and remove
 it from the connection cache.

* Add various error handling tests for connections and peer operations, and
look at moving some of the code to pipelines.

------------

Supporting experiments:

* insertion
 - to push nodes onto a peer

* enable logging of typical networking metrics:
 - bytes
 - messages
 - peers
 - latency

* implement recursive and iterative operators
* implement query packet TTL counter that decrements at each hop
 - packets dropped when (zero? TTL)
* implement latency introducer stage in pipeline so we can simulate larger
networks

----------------------------------------------------------

Move to records and a standard protocol for query.operators:

* Goal: standardize the interface and access to important operator info
  - dataflow dependencies for optimizing query plan
  - specific arguments by name for re-organizing operators, combining operators

methods:
* branch?
 - replaces the operator/op-branch-map
* plan version
* instance version

-------------------------------

* insert node/edge
* update node/edge
* delete node/edge

-------------------------------
Long Term:
-------------------------------

* look into jiraph versioning mechanism
